
-[ name patterns ]-

keywords =      '[a-z]+'
variables =     '[a-zA-Z_][a-zA-Z_0-9]*'
types =         '[a-zA-Z_][a-zA-Z_0-9]*'
labels =        '[a-zA-Z_][a-zA-Z_0-9]*'

a   b       &   |   ^
x   x       t   t   f
x           f   t   t
    x       f   t   t
            f   f   f

-[ line patterns ]-

VAR_DEF: ( 'var' | 'const' | 'let' | 'ref' ) <NAME> [':' <TYPE>] [ '=' <EXP> ]

FUNC_DEF: 'def' <NAME> '(' <ARGS> ')'

TYPE_DEF: 'type' <NAME> '=' <TYPE_EXP>

TYPE_FUNC_DEF: 'type'

ARGS: [ <VAR_DEF> ] [ ',' VAR_DEF ]*

YIELD: 'yield' [ <EXP> ]
RETURN: 'return' [ <EXP> ]

GOTO: 'goto' <LABEL>
LABEL: 'label' <LABEL>

'if' <EXP> 'then' <STATEMENT>

'if' <EXP>
'else' 'if' <EXP>
'else'

'repeat' <EXP>

'for' [ <INIT> ]; [ <COND> ]; [ <STEP> ]
'for' <NAME> 'in' <EXP>

'while' <COND>

'switch' <EXP>
'case' <EXP>
'default'

'break'
'continue'

'end' [ 'def' [ <NAME> ] | 'type' [ <NAME> ] |
        'if' | 'repeat' | 'for' | 'while' | 'switch' ]


type <NAME> : <TYPE>
def type <NAME> ( <ARGS> ) [ : <TYPE> ]

class <NAME> [ : <PARENT> ]

private
public

end [
    class [ <NAME> ] |
    type <NAME> |
    type [ function [ <NAME> ] ]
]
