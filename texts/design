
# patterns

keywords =		'[a-z]+'
annotation =	'[a-z]+'

variables =		'[a-zA-Z_][a-zA-Z_0-9]*'
types =			'[a-zA-Z_][a-zA-Z_0-9]*'
labels =		'[a-zA-Z_][a-zA-Z_0-9]*'

# built-in types:
	char                    'a'
	int                     1, 0x01, 0b01, 01
	float                   1.0
	string                  "Hello"
	array					[]
	boolean					T, F
	null					N
	function				def (a, b) => a + b

# string kinds:

raw string: use 'r' before strings
	r"hello \" world" -> hello " world
	r"hello \\ world" -> hello \ world

formated string: use 'f' before strings
	var name = "World"
	f"Hello {name}!" -> "Hello World!"

multi-line strings:
        a = "\
    hello, I'm here to answer you.
    "

math operations:
	+		add					%		mod
	-		sub					//		true div
	*		mul					**		exp
	/		div
	
	+=		add assign
	-=		sub assign
	*=		mul	assign
	/=		div assign

	==		equal				!=		not equal
	<		less than			<=		less than equal
	>		greater than		>=		greater than equal

	&		bitwisze and		and		logic and
	|		bitwisze or			or 		logic or
	^		bitwisze xor		xor		logic xor
	~		bitwisze not		not		logic not

	<<		shift left
	>>		shift right


# built-in types fields:

var array = [1, 2, 3]
var length = array.length
var item = array[2]
var new_array = array[0:-1]                 # new_array == [1, 2]

var string = "Hello"
var length = string.length
var item = string[5]                        # item ?= char
var new_string = string[::-1]               # new_string == "olleH"

# built-in types functions:

def int.is_natural() = (self > 0)

def string.is_lower()
	for ch in self
		if ! ('a' <= ch <= 'z')
			return false
		end
	end
	return true
end

# annotation definition:

@public
val a = 10

@private
val b = 30

# value definition

val a = 0

# variable definition

var b = 1

# name definition

var a = 1
let b => a + 2

# reference definition

var a = 1
ref b => a

# function definition:

def sum(val a: int, val b: int): int => a + b

def range(val start: int, val stop: int, val step: int): int[]
	for i = start; i < stop; i += step
		yield i
	end
end

def Hello(val name: = N)
	printf("Hello {}!", (name instanceof null) ? "World" : name)
end

# operations:

# type definitions:

type number = int
type numbers = int[]

def type unsigned => (self ?= int) && (self >= 0)
def type signed => (self ?= int)

def type int_limit(min: int, max: int)
	return (self ?= int) && (self >= min) && (self <= max)
end

var a: unsigned = 100
var b: int_limit(100, 200) = 150

# type definition examples:

	int[]					[1, 2, 3, 4]		; array of ints
	int[3]					[1, 2, 3]			; array of three ints
	[int, int]				[1, 2]				; array of two ints

	{x: int, y: int}		{10, 20}			; dict of two ints
	{name, age}				{"Jack", 20}		; dict of a name and an age

	null or string			N					; a null or string
	null or int				10					; a null or int
	(int or string)[]		[1, "Hi"]			; array of int or string

# dict:

it's a type.

dict Person
	name: string or null
	age: int

	def hello(name = N)
		name = (name == N) ? f" {name}," : ","
		print(f"Hello {name}, my name is {self.name}")
	end

	def $()
		return "Person({}, {})" % (name, age)
	end
end

val persons = [val 1, val 2]

var me = new Person("Amin", 20)

persons.hello()

# class:

class Person
	val name: string
	val age: int

	def Person (name: string, age: int)
		self.name = name
		self.age = age
	end

	def greeting (name: string or null = N)
		if name == N
			printf("Hello, my name is {}.", self.name)
		else
			printf("Hello {}, my name is {}.", name, self.name)
		end
	end
end

# interface:

interface Person
	def get_name(): string
	def get_age(): int
end

val persons = [
	new Person("Amin", 21),
	new Person("Armin", 17),
	]

val me: Person = new Person("Amin", 21)
me.greeting("Armin")

class ConstPoint
	val x
	val y

	def Point(var x, var y)
		self.x = x
		self.y = y
	end
end

class Point extends ConstPoint
	var x
	var y

	def add(val a)
		self.x += a
		self.y += a
	end

	def add(val x, val y)
		self.x += x
		self.y += y
	end

	def sub(val a)
		self.x -= a
		self.y -= a
	end
end

# structure:

struct Point
	x: int
	y: int

	def add (point: Point)
		self.x += point.x
		self.y += point.y
	end

	def distance (point: Point)
		return ((self.x - point.x) ** 2 + (self.y - point.y) ** 2) ** (1 / 2)
	end

	def +(other: Point or int): Point
		if other ?= Point
			return {self.x + other.x, self.y + other.y}
		else if other ?= int
			return {self.x }
		end
	end

	def -(other: Point or int)
		if other ?= Point
			return 
	end
end


if name.empty() and 



var points = [
	new Point {x = 10, y = 20},
	new Point {x = 30, y = 40},
	]

points 

## control flow:

# goto

label Hello
goto Hello

# if

if COND
	STATEMENT
if COND
	STATEMENT
else if COND
	STATEMENT
else
	STATEMENT
end

if COND then STATEMENT

# repeat

repeat VALUE
	STATEMENT
end

repeat VALUE do STATEMENT

# for 3 part

for INIT; TEST; STEP
	STATEMENT
else
	STATEMENT
end

for INIT; TEST; STEP do STATEMENT

# for iterable

for NAME in ITER
	STATEMENT
else
	STATEMENT
end

for NAME in ITER do STATEMENT

# while

while COND
	STATEMENT
else
	STATEMENT
end

while COND do STATEMENT

# do while ??s

# switch

switch VALUE
	case VALUE
		STATEMENT
		break

	case VALUE
		STATEMENT
		break

	case VALUE
		STATEMENT
		break

	default
		STATEMENT
		break
end
