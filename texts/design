
# keywords:
	from        import      as

	goto        label
	if          do			else        end
	repeat      for         in          while
	switch      case        default
	
	break       continue

	var         val         let         ref
	def         yield       return

	type        untype
	struct      class       self        new
	space
	public      private

	true        false       null

# built-in types:
	char                    'a'
	int                     1, 0x01, 0b01, 01
	float                   1.0
	string                  "Hello"
	array					[]
	boolean					T, F
	null					N
	function				def (a, b) => a + b


# built-in types fields:

var array = [1, 2, 3]
var length = array.length
var item = array[2]
var new_array = array[0:-1]                 # new_array == [1, 2]

var string = "Hello"
var length = string.length
var item = string[5]                        # item ?= char
var new_string = string[::-1]               # new_string == "olleH"

# built-in types functions:

def int.is_natural() = (self > 0)

def string.is_lower()
	for ch in self
		if ! ('a' <= ch <= 'z')
			return false
		end
	end
	return true
end

# type definitions:
	int[]                   [1, 2, 3, 4]        ; array of ints
	int[3]                  [1, 2, 3]           ; array of three ints
	[int, int]              [1, 2]              ; array of two ints
	(int | string)[]		[1, "Hi"]			; array of int or string

# value definition

val a = 0

# variable definition

var b = 1

# name definition

var a = 1
let b => a + 2

# reference definition

var a = 1
ref b => a

# functions:

def sum(val a: int, val b: int): int => a + b

def range(val start: int, val stop: int, val step: int): <int>
	for i = start; i < stop; i += step
		yield i
	end
end

# types:

type number = int
type numbers = array[number]

type null_string = null | string

type null_int = null | int

def type unsigned = (self ?= int) && (self >= 0)
def type signed = (self ?= int)

def type int_limit(var min: int, var max: int)
	return (self ?= int) && (self >= min) && (self <= max)
end

var a: unsigned = 100
var b: int_limit(100, 200) = 150

# class:

class Person implements Person
	val name: string
	val age: int

	def Person (name: string, age: int)
		self.name = name
		self.age = age
	end

	def greeting (name: string = "")
		if name == ""
			printf("Hello, my name is {}.", self.name)
		else
			printf("Hello {}, my name is {}.", name, self.name)
		end
	end
end

def Hello(val name: = N)
	printf("Hello " + (name == N ? "World" : name) + "!")
	printf("Hello {}!", (name instanceof null) ? "World" : name)
end

val me: Person = new Person("Amin", 21)
me.greeting("Armin")

val persons = [
	new ConstPerson("Amin", 21),
	new ConstPerson("Armin", 17),
	]

class Point <T>
	var x: T
	var y: T

	def Point(var x: T, var y: T)
		self.x = x
		self.y = y
	end
end

# structure:

struct Point
	var x: int
	var y: int

	def add (point: Point)
		self.x += point.x
		self.y += point.y
	end

	def distance (point: Point): float
		return ((self.x - point.x) ** 2 + (self.y - point.y) ** 2) ** (1 / 2)
	end
end

var points = [
	new Point {10, 20},
	new Point {30, 40},
	]

## control flow:

# goto

label Hello
goto Hello

# if

if COND
	STATEMENT
if COND
	STATEMENT
else if COND
	STATEMENT
else
	STATEMENT
end

if COND do STATEMENT

# repeat

repeat VALUE
	STATEMENT
end

# for 3 part

for INIT; TEST; STEP
	STATEMENT
else
	STATEMENT
end

for INIT; TEST; STEP do STATEMENT

# for iterable

for NAME in ITER
	STATEMENT
else
	STATEMENT
end

for NAME in ITER do STATEMENT

# while

while COND
	STATEMENT
else
	STATEMENT
end

while COND do STATEMENT

# do while ??s

# switch

switch VALUE
	case VALUE
		STATEMENT
		break

	case VALUE
		STATEMENT
		break

	case VALUE
		STATEMENT
		break

	default
		STATEMENT
		break
end

# operations:
	+		add
	-		sub
	*		mul
	/		div

	%		mod
	//		true div
	**		exp

	&		bitwise and
	|		bitwise or
	^		bitwise xor
	~		bitwise not

	>>		shift right
	<<		shift left

	=		assign
	=>		ref assign

	==		equal
	!=		not equal
	<		less than
	<=		less than equal
	>		greater than
	>=		greater than equal

	&&		and
	||		or
	^^		xor
	!		not

	+=		add assign
	-=		sub assign
	*=		mul	assign
	/=		div assign

	%=		mod assign
	//=		true div assign
	**=		exp assign

	&=		bitwise and assign
	|=		bitwise or assign
	^=		bitwise xor assign

	>>=		shift right assign
	<<=		shift left assign
