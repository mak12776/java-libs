
for register names:
				al, ah, ax, eax, rax
				bl, bh, bx, ebx, rbx
				cl, ch, cx, ecx, rcx
				dl, dh, dx, edx, rdx

				sl, sh, sx, esx, rsx
				tl, th, tx, etx, rtx
				ul, uh, ux, eux, rux
				vl, vh, vx, evx, rvx


examples:
	byte
	word
	double
	quad

	char
	short
	int
	long

	double
	float

	mov 	eax, ebx           		; eax = ebx
	mov 	[0], 10                 ; [0] = 10	<- unknown size


** String Machine Assembly
address size: 32 bit

number of address size: 8

- registers:
	ap, bp, cp, dp, 	ep, fp, gp, hp

- instructions:

** java Little Machine

address size: 32 bit

- symbols:
	A32		immediate address
	IP		instruction pointer
	BP		buffer pointer
	[BP]	bytes pointed by BF

- instructions:
	copy	A32, IP
	copy	A32, BP

	copy	IP, BP
	copy	BP, IP

	copy	BP, BP

	copy	1 [BP], [BP]

	swap	

** Little Machine Assembly

address size: 32 bit
register size: 32 bit

	symbol			size			value			description
	[i32]			unknown			unknown			memory address
	[r32]			unknown			unknown			memory address in register
	i8/16/32		8/16/32			known			immediate
	r8/16/32		8/16/32			unknown			register

- registers:
	al, ah, ax, eax
	bl, bh, bx, ebx
	cl, ch, cx, ecx
	dl, dh, dx, edx

	sl, sh, sx, esx
	tl, th, tx, etx
	ul, uh, ux, eux
	vl, vh, vx, evx

	ip

number of r8: 	16
number of r16:	8
number of r32:	8

number of bits for r8: 	4
number of bits for r16:	3
number of bits for r32:	3

- instructions:

move:
	mov		a, 		b			; a = b, a.size = b.size
	mov		r/m, 	r/m/i

	inst	oprands					modes		bits		bits sum	empty bits
	mov		[im32],		r8			-, 16		32, 4		36			4

	mov		r8,			r8			16,	15		4, 4		8			-
	mov		r16, 		r16			8, 7		3, 3		6			2
	mov		r32, 		r32			8, 7		3, 3		6			2

	mov		[im32], 	im8			-			32, 8		40			-
	mov		[im32], 	im16		-			32, 16		48			-
	mov		[im32], 	im32		-			32, 32		64			-

	mov		r8,			im8			16, -		4, 8		12			4
	mov		r16,		im16		8,	-		3, 16		19			5
	mov		r32,		im32		8, -		3, 32		35			5


** Ultra 64Bit Machine Assembly

address size: 64 bit
register size: 64 bit

	note: # = address size

- registers:
	register number: N

	r<n>[bwdq]<m>		; general registers
	ip					; instruction pointer, size = 64

											if P = 5 -> N = 32
number of r8:	8 * N		2 ** (3 + P)	2 ** 8
number of r16:	4 * N		2 ** (2 + P)	2 ** 7
number of r32:	2 * N		2 ** (1 + P)	2 ** 6
number of r64:	1 * N		2 ** (0 + P)	2 ** 5

operands:
	r8/16/32/64		or		r
	[r64]			or		[r]
	im8/16/32/64	or		im
	[im64]			or		[im]

- instructions:
	mov		a, b 												; a <- b
	mov		r/m, r/m/i

move table:

	inst	operands							type			sum of operands size

	-
	mov		r8/16/32/64		im8/16/32/64		r - im			r8 + 8		r16 + 16	r32 + 32	r64 + 64
	mov		[r64]			im8/16/32/64		[r] - im		r64 + 8		r64 + 16	r64 + 32	r64 + 64
	mov		[im64]			im8/16/32/64		[im] - im		64 + 8		64 + 16		64 + 32		64 + 64
	***											im - im

	-
	mov		r8/16/32/64		r8/16/32/64			r - r			r8 + r8		r16 + r16	r32 + r32	r64 + r64

	mov		[r64]			r8/16/32/64			[r] - r			64 + r8		64 + r16	64 + r32	64 + r64
	mov 	r8/16/32/64		[r64]								r8 + r64	r16 + r64	r32 + r64	r64 + r64

	mov		[im64]			r8/16/32/64			[im] - r
	mov		r8/16/32/64		[im64]

	-
	mov		[r64]			[r64]				[r] - [r]		; size = 8/16/32/64

	mov		[im64]			[r64]				[im] - [r]
	mov		[r64]			[im64]

	-
	***											[im] - [im]

address size: 32 bit
register size: 64 bit

- registers name: 
	r<n>[bwdq]<k>		; general registers
	ip					; instruction pointer, size = 64

operands symbols:
	symbol		operands			size			value 			description
	[im]		[i#]				unknown			unknown			memory address
	[r]			[r#]				unknown			unknown			memory address in register
	im			i8/16/32/64			8/16/32/64		known			immediate
	r			r8/16/32/64			8/16/32/64		unknown			register
	ip			ip					32				unknown			instruction pointer

instruction list:
	mov		a		b			; a <= b, a.size = b.size
	mov		r/m		r/m/i		; a.size = b.size

	xchg	a		b			; a <= b, b <= a
	xchg	r/m		r/m

two operands instruction summary:
	opr1 		opr2
	r			im
	[r]			im
	[im]		im

	r			r
	[r]			r
	[im]		r

	r			[r]
	[r]			[r]
	[im]		[r]

	r			[im]
	[r]			[im]

	r/[r]/[im]	im/r/[r]/[im]

number of registers: N

.											if P = 5 -> N = 32
number of r8:	8 * N		2 ** (3 + P)	2 ** 8
number of r16:	4 * N		2 ** (2 + P)	2 ** 7
number of r32:	2 * N		2 ** (1 + P)	2 ** 6
number of r64:	1 * N		2 ** (0 + P)	2 ** 5

two operand instruction summary:

	opr1				opr2
	r8/16/32/64			im8/16/32/64
	[r64]				..
	[im64]



	inst	opr1	opr2

	mov		r8		im8			
	mov		r16		im16
	mov		r32		im32
	mov		r64		im64

	mov		[r64]	im8
	mov		[r64]	im16
	mov		[r64]	im32
	mov		[r64]	im64

	mov		[im64]	im8
	mov		[im64]	im16
	mov		[im64]	im32
	mov		[im64]	im64

	mov		r8		r8
	mov		r16		r16
	mov		r32		r32
	mov		r64		r64

	mov		[r64]	r8
	mov		[r64]	r16
	mov		[r64]	r32
	mov		[r64]	r64

	mov		[im64]	r8
	mov		[im64]	r16
	mov		[im64]	r32
	mov		[im64]	r64

	mov		r8		[r64]
	mov		r16		[r64]
	mov		r32		[r64]
	mov		r64		[r64]

	mov		[r64]	[r64]		8
	mov		[r64]	[r64]		16
	mov		[r64]	[r64]		32
	mov		[r64]	[r64]		64

	mov		[im64]	[r64]		8
	mov		[im64]	[r64]		16
	mov		[im64]	[r64]		32
	mov		[im64]	[r64]		64

	mov		r8		[im64]		-		
	mov		r16		[im64]		-
	mov		r32		[im64]		-
	mov		r64		[im64]		-

	mov		[r64]	[im64]		8
	mov		[r64]	[im64]		16
	mov		[r64]	[im64]		32
	mov		[r64]	[im64]		64


xchg table:
	inst 	operands


- registers example:

			a[0]	a[1]	a[2]	a[3]		a[4]	a[5]	a[6]	a[7]
	a		00		00		00		00			00		00		00		00

	ax		ax[0]			ax[2]				ax[3]			ax[4]
			00		00		00		00			00		00		00		00

	eax		eax[0]								eax[1]
			00		00		00		00			00		00		00		00

			ar
	ar		00		00		00		00			00		00		00		00


- old mov instruction:

	[addr32]      im8/16/32           32  8/16/32     0

	[r32]         im8/16/32           3   8/16/32     3   a

	r8            im8                 4   8           4
	r16           im16                3   16          3   a
	r32           im32                3   32          3   a


	[addr32]      r8                  32  4           4
	[addr32]      r16                 32  3           3   a
	[addr32]      r32                 32  3           3   a

	[r32]         r8                  3   4           7
	[r32]         r16                 3   3           6
	[r32]         r32                 3   3           6

	r8            r8                  4   4           0
	r16           r16                 3   3           6
	r32           r32                 3   3           6


	[addr32]      [addr32]            32  32          0

	[r32]         [addr32]            3   32          5

	r8            [addr32]            4   32          4
	r16           [addr32]            3   32          3   a
	r32           [addr32]            3   32          3   a


for
register names: al, ax, eax, rax
                bl, bx, ebx, rbx
                cl, cx, ecx, rcx
                dl, dx, edx, rdx

                sl, sx, esx, rsx
                tl, tx, etx, rtx
                ul, ux, eux, rux
                vl, vx, evx, rvx
.

[addr32]      im8/16/32           32  8/16/32     0

[r32]         im8/16/32           32
